# 智能客服系统后端开发指南

## 概述

智能客服系统后端采用Flask 3.0 + SQLAlchemy 2.0技术栈，提供完整的API接口服务，支持用户认证、店铺管理、消息处理、知识库管理、审核队列等核心功能。

## 技术栈

### 核心框架
- **Flask 3.0**: 轻量级Web框架
- **SQLAlchemy 2.0**: ORM框架
- **Flask-Migrate**: 数据库迁移
- **Flask-Login**: 用户认证
- **Flask-CORS**: 跨域支持

### 数据库支持
- **SQLite**: 开发环境
- **MySQL**: 生产环境
- **Alembic**: 数据库迁移工具

### 任务调度
- **APScheduler**: 定时任务调度
- **BackgroundScheduler**: 后台任务调度

### 其他依赖
- **Pillow**: 图像处理
- **pyautogui**: UI自动化
- **pywin32**: Windows系统集成
- **requests**: HTTP请求
- **pandas**: 数据处理

## 项目结构

```
houduan/
├── app.py                  # Flask应用入口
├── config.py              # 配置管理
├── models/                 # 数据模型层
│   └── __init__.py        # 模型定义
├── api/                    # API接口层
│   ├── __init__.py        # API蓝图
│   ├── auth.py            # 认证接口
│   ├── shops.py           # 店铺管理
│   ├── messages.py        # 消息处理
│   ├── audit.py           # 审核队列
│   ├── kb.py              # 知识库管理
│   ├── statistics.py      # 统计接口
│   ├── users.py           # 用户管理
│   └── simple/            # 简化版API
├── services/              # 业务逻辑层
│   ├── qianniu_monitor.py # 千牛监控
│   ├── ai_adapter.py      # AI适配器
│   ├── message_handler.py # 消息处理
│   ├── knowledge_base.py  # 知识库服务
│   ├── vector_search.py   # 向量搜索
│   ├── scheduler.py       # 任务调度
│   ├── alert.py           # 告警服务
│   └── db_health.py       # 数据库健康检查
├── utils/                 # 工具函数层
│   ├── db_manager.py      # 数据库管理
│   ├── cache_manager.py   # 缓存管理
│   ├── connection_pool.py # 连接池
│   ├── context_manager.py # 上下文管理
│   ├── query_optimizer.py # 查询优化
│   └── security.py        # 安全工具
└── migrations/            # 数据库迁移
    ├── alembic.ini        # Alembic配置
    ├── env.py            # 环境配置
    └── versions/          # 迁移版本
```

## 应用工厂模式

### 应用入口 (app.py)

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_login import LoginManager
from flask_cors import CORS
import os

# 全局扩展
db = SQLAlchemy()
migrate = Migrate()
login_manager = LoginManager()

def create_app(config_name=None):
    """应用工厂函数"""
    app = Flask(__name__)
    
    # 配置
    if config_name:
        app.config.from_object(f'config.{config_name}')
    else:
        app.config.from_object('config.Config')
    
    # 初始化扩展
    db.init_app(app)
    migrate.init_app(app, db)
    login_manager.init_app(app)
    CORS(app, resources={r"/*": {"origins": ["http://localhost:5173", "http://localhost:5174"]}})
    
    # 配置登录管理器
    login_manager.login_view = 'api.login'
    login_manager.login_message = '请先登录'
    login_manager.login_message_category = 'info'
    
    # 注册蓝图
    from .api import api_bp
    app.register_blueprint(api_bp, url_prefix='/api')
    
    # 健康检查
    @app.route('/health')
    def health():
        return {'status': 'ok', 'message': '服务运行正常'}
    
    # 启动后台任务
    from .services.scheduler import start_scheduler
    start_scheduler(app)
    
    return app

# 创建应用实例
app = create_app()

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5002)
```

### 配置管理 (config.py)

```python
import os
from datetime import timedelta

class Config:
    """基础配置"""
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key-change-in-production'
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///data/sqlite.db'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_ENGINE_OPTIONS = {
        'pool_pre_ping': True,
        'pool_recycle': 300,
    }
    
    # 登录配置
    LOGIN_DISABLED = False
    PERMANENT_SESSION_LIFETIME = timedelta(hours=24)
    
    # CORS配置
    CORS_ORIGINS = ['http://localhost:5173', 'http://localhost:5174']
    
    # 任务调度配置
    SCHEDULER_API_ENABLED = True
    SCHEDULER_TIMEZONE = 'Asia/Shanghai'
    
    # AI模型配置
    OPENAI_API_KEY = os.environ.get('OPENAI_API_KEY')
    OPENAI_MODEL = os.environ.get('OPENAI_MODEL', 'gpt-4o-mini')
    
    # 告警配置
    ALERT_SMTP_SERVER = os.environ.get('ALERT_SMTP_SERVER')
    ALERT_SMTP_PORT = int(os.environ.get('ALERT_SMTP_PORT', 587))
    ALERT_EMAIL_USERNAME = os.environ.get('ALERT_EMAIL_USERNAME')
    ALERT_EMAIL_PASSWORD = os.environ.get('ALERT_EMAIL_PASSWORD')
    ALERT_EMAIL_TO = os.environ.get('ALERT_EMAIL_TO', '').split(',')
    ALERT_WEBHOOK_URL = os.environ.get('ALERT_WEBHOOK_URL')
    ALERT_WEBHOOK_TYPE = os.environ.get('ALERT_WEBHOOK_TYPE', 'wechat')

class DevelopmentConfig(Config):
    """开发环境配置"""
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///data/sqlite.db'

class ProductionConfig(Config):
    """生产环境配置"""
    DEBUG = False
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')
    
    # 生产环境安全配置
    SESSION_COOKIE_SECURE = True
    SESSION_COOKIE_HTTPONLY = True
    SESSION_COOKIE_SAMESITE = 'Lax'

# 配置字典
config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}
```

## 数据模型设计

### 基础模型 (models/__init__.py)

```python
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash

db = SQLAlchemy()

class TimestampMixin:
    """时间戳混入类"""
    created_at = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

class User(db.Model, TimestampMixin):
    """用户模型"""
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    role = db.Column(db.String(32), nullable=False, default='agent')
    shop_id = db.Column(db.Integer, db.ForeignKey('shops.id'), nullable=True)
    
    def set_password(self, password):
        """设置密码"""
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        """验证密码"""
        return check_password_hash(self.password_hash, password)
    
    def __repr__(self):
        return f'<User {self.username}>'

class Shop(db.Model, TimestampMixin):
    """店铺模型"""
    __tablename__ = 'shops'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), unique=True, nullable=False)
    qianniu_title = db.Column(db.String(256), nullable=True)
    config_json = db.Column(db.Text, nullable=True)
    
    # 关系
    users = db.relationship('User', backref='shop', lazy='dynamic')
    messages = db.relationship('Message', backref='shop', lazy='dynamic')
    
    def __repr__(self):
        return f'<Shop {self.name}>'

class Message(db.Model, TimestampMixin):
    """消息模型"""
    __tablename__ = 'messages'
    
    id = db.Column(db.Integer, primary_key=True)
    shop_id = db.Column(db.Integer, db.ForeignKey('shops.id'), nullable=False)
    customer_id = db.Column(db.String(128), nullable=False)
    content = db.Column(db.Text, nullable=False)
    source = db.Column(db.String(32), nullable=False, default='qianniu')
    status = db.Column(db.String(32), nullable=False, default='new')
    handled_by = db.Column(db.String(64), nullable=True)
    
    # 关系
    ai_replies = db.relationship('AIReply', backref='message', lazy='dynamic')
    audit_items = db.relationship('AuditQueueItem', backref='message', lazy='dynamic')
    
    def __repr__(self):
        return f'<Message {self.id}: {self.content[:50]}...>'

class KnowledgeBaseItem(db.Model, TimestampMixin):
    """知识库条目模型"""
    __tablename__ = 'knowledge_base'
    
    id = db.Column(db.Integer, primary_key=True)
    shop_id = db.Column(db.Integer, db.ForeignKey('shops.id'), nullable=True)
    question = db.Column(db.Text, nullable=False)
    answer = db.Column(db.Text, nullable=False)
    category = db.Column(db.String(64), nullable=True)
    keywords = db.Column(db.String(512), nullable=True)
    
    # 关系
    vectors = db.relationship('KnowledgeVector', backref='kb_item', lazy='dynamic')
    
    def __repr__(self):
        return f'<KnowledgeBaseItem {self.id}: {self.question[:50]}...>'

class KnowledgeVector(db.Model, TimestampMixin):
    """知识库向量模型"""
    __tablename__ = 'knowledge_vectors'
    
    id = db.Column(db.Integer, primary_key=True)
    kb_item_id = db.Column(db.Integer, db.ForeignKey('knowledge_base.id'), nullable=False)
    vector = db.Column(db.LargeBinary, nullable=False)
    dim = db.Column(db.Integer, nullable=False)
    
    def __repr__(self):
        return f'<KnowledgeVector {self.id}: dim={self.dim}>'

class AIReply(db.Model, TimestampMixin):
    """AI回复模型"""
    __tablename__ = 'ai_replies'
    
    id = db.Column(db.Integer, primary_key=True)
    message_id = db.Column(db.Integer, db.ForeignKey('messages.id'), nullable=False)
    model = db.Column(db.String(64), nullable=False)
    reply = db.Column(db.Text, nullable=False)
    confidence = db.Column(db.Float, nullable=True)
    review_status = db.Column(db.String(32), nullable=False, default='auto')
    
    def __repr__(self):
        return f'<AIReply {self.id}: {self.reply[:50]}...>'

class AuditQueueItem(db.Model, TimestampMixin):
    """审核队列表模型"""
    __tablename__ = 'audit_queue'
    
    id = db.Column(db.Integer, primary_key=True)
    message_id = db.Column(db.Integer, db.ForeignKey('messages.id'), nullable=False)
    assigned_to = db.Column(db.String(64), nullable=True)
    status = db.Column(db.String(32), nullable=False, default='pending')
    note = db.Column(db.Text, nullable=True)
    
    def __repr__(self):
        return f'<AuditQueueItem {self.id}: {self.status}>'

class StatisticsDaily(db.Model, TimestampMixin):
    """每日统计模型"""
    __tablename__ = 'statistics_daily'
    
    id = db.Column(db.Integer, primary_key=True)
    date = db.Column(db.Date, nullable=False, unique=True)
    kb_hit_rate = db.Column(db.Float, nullable=True)
    ai_accuracy = db.Column(db.Float, nullable=True)
    
    def __repr__(self):
        return f'<StatisticsDaily {self.date}: kb_hit={self.kb_hit_rate}>'
```

## API接口开发

### 认证接口 (api/auth.py)

```python
from flask import request, jsonify
from flask_login import UserMixin, login_user, logout_user
from . import api_bp
from ..models import User

class LoginUser(UserMixin):
    """登录用户类"""
    def __init__(self, user):
        self._user = user
    
    @property
    def id(self) -> str:
        return str(self._user.id)
    
    @property
    def role(self) -> str:
        return self._user.role

@api_bp.post("/auth/login")
def login():
    """用户登录"""
    try:
        data = request.get_json()
        username = data.get("username", "").strip()
        password = data.get("password", "")
        
        if not username or not password:
            return jsonify({"error": "username_password_required"}), 400
        
        # 查找用户
        user = User.query.filter_by(username=username).first()
        if not user or not user.check_password(password):
            return jsonify({"error": "invalid_credentials"}), 401
        
        # 登录用户
        login_user(LoginUser(user))
        return jsonify({
            "ok": True,
            "user": {
                "id": user.id,
                "username": user.username,
                "role": user.role
            }
        })
    except Exception as e:
        return jsonify({"error": "internal_error", "detail": str(e)}), 500

@api_bp.post("/auth/logout")
def logout():
    """用户登出"""
    logout_user()
    return jsonify({"ok": True})
```

### 店铺管理接口 (api/shops.py)

```python
from flask import request, jsonify
from flask_login import login_required
from . import api_bp
from ..models import Shop
from ..utils.security import require_roles

@api_bp.get("/shops")
@login_required
def list_shops():
    """获取店铺列表"""
    try:
        shops = Shop.query.order_by(Shop.id.desc()).all()
        result = []
        
        for shop in shops:
            # 解析配置JSON
            config = {}
            if shop.config_json:
                try:
                    import json
                    config = json.loads(shop.config_json)
                except Exception:
                    config = {}
            
            result.append({
                "id": shop.id,
                "name": shop.name,
                "qianniu_title": shop.qianniu_title,
                "ocr_region": config.get("ocr_region", []),
                "unread_threshold": config.get("unread_threshold"),
                "ai_model": config.get("ai_model", "stub"),
                "auto_mode": config.get("auto_mode", False),
                "blacklist": config.get("blacklist", []),
                "whitelist": config.get("whitelist", []),
                "business_hours": config.get("business_hours"),
                "reply_delay": config.get("reply_delay", 2)
            })
        
        return jsonify(result)
    except Exception as e:
        return jsonify({"error": "database_error", "detail": str(e)}), 500

@api_bp.post("/shops")
@login_required
@require_roles("superadmin", "admin")
def create_shop():
    """创建店铺"""
    try:
        data = request.get_json()
        name = data.get("name", "").strip()
        
        if not name:
            return jsonify({"error": "name_required"}), 400
        
        # 检查店铺名称是否已存在
        if Shop.query.filter_by(name=name).first():
            return jsonify({"error": "shop_name_exists"}), 400
        
        # 构建配置JSON
        config_data = {
            "ocr_region": data.get("ocr_region", []),
            "unread_threshold": data.get("unread_threshold", 0.02),
            "ai_model": data.get("ai_model", "stub"),
            "auto_mode": data.get("auto_mode", False),
            "blacklist": data.get("blacklist", []),
            "whitelist": data.get("whitelist", []),
            "business_hours": data.get("business_hours"),
            "reply_delay": data.get("reply_delay", 2)
        }
        
        import json
        config_json = json.dumps(config_data, ensure_ascii=False)
        
        # 创建店铺
        shop = Shop(
            name=name,
            qianniu_title=data.get("qianniu_title"),
            config_json=config_json
        )
        
        db.session.add(shop)
        db.session.commit()
        
        return jsonify({
            "id": shop.id,
            "name": shop.name,
            "qianniu_title": shop.qianniu_title
        }), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": "database_error", "detail": str(e)}), 500

@api_bp.put("/shops/<int:shop_id>")
@login_required
@require_roles("superadmin", "admin")
def update_shop(shop_id: int):
    """更新店铺"""
    try:
        shop = Shop.query.get_or_404(shop_id)
        data = request.get_json()
        
        # 更新基本信息
        if "name" in data:
            shop.name = data["name"].strip()
        if "qianniu_title" in data:
            shop.qianniu_title = data["qianniu_title"]
        
        # 更新配置
        config_data = {
            "ocr_region": data.get("ocr_region", []),
            "unread_threshold": data.get("unread_threshold", 0.02),
            "ai_model": data.get("ai_model", "stub"),
            "auto_mode": data.get("auto_mode", False),
            "blacklist": data.get("blacklist", []),
            "whitelist": data.get("whitelist", []),
            "business_hours": data.get("business_hours"),
            "reply_delay": data.get("reply_delay", 2)
        }
        
        import json
        shop.config_json = json.dumps(config_data, ensure_ascii=False)
        
        db.session.commit()
        return jsonify({"ok": True})
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": "database_error", "detail": str(e)}), 500

@api_bp.delete("/shops/<int:shop_id>")
@login_required
@require_roles("superadmin")
def delete_shop(shop_id: int):
    """删除店铺"""
    try:
        shop = Shop.query.get_or_404(shop_id)
        
        # 删除相关数据
        from ..models import Message, KnowledgeBaseItem, ReplyTemplate, User
        
        # 删除相关消息
        Message.query.filter_by(shop_id=shop_id).delete()
        
        # 删除相关知识库条目
        KnowledgeBaseItem.query.filter_by(shop_id=shop_id).delete()
        
        # 删除相关回复模板
        ReplyTemplate.query.filter_by(shop_id=shop_id).delete()
        
        # 清除相关用户的店铺关联
        User.query.filter_by(shop_id=shop_id).update({"shop_id": None})
        
        # 删除店铺
        db.session.delete(shop)
        db.session.commit()
        
        return jsonify({"ok": True})
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": "delete_failed", "detail": str(e)}), 500
```

## 业务逻辑服务

### 消息处理服务 (services/message_handler.py)

```python
from typing import NamedTuple
from ..models import Message, KnowledgeBaseItem, AIReply, AuditQueueItem
from .knowledge_base import search_knowledge_base
from .ai_adapter import get_ai_reply

class ProcessResult(NamedTuple):
    """处理结果"""
    reply: str
    source: str  # 'kb' or 'ai'
    auto_send: bool
    confidence: float

def process_message(message: Message) -> ProcessResult:
    """处理消息"""
    try:
        # 1. 知识库搜索
        kb_result = search_knowledge_base(message.content, message.shop_id)
        
        if kb_result and kb_result.confidence > 0.9:
            # 高置信度，直接使用知识库答案
            return ProcessResult(
                reply=kb_result.answer,
                source='kb',
                auto_send=True,
                confidence=kb_result.confidence
            )
        elif kb_result and kb_result.confidence > 0.6:
            # 中等置信度，知识库+AI增强
            ai_reply = get_ai_reply(message.content, kb_result.answer)
            return ProcessResult(
                reply=ai_reply,
                source='ai',
                auto_send=False,
                confidence=kb_result.confidence
            )
        else:
            # 低置信度，纯AI处理
            ai_reply = get_ai_reply(message.content)
            return ProcessResult(
                reply=ai_reply,
                source='ai',
                auto_send=False,
                confidence=0.5
            )
    except Exception as e:
        # 处理失败，返回默认回复
        return ProcessResult(
            reply="抱歉，我暂时无法处理您的问题，请稍后再试。",
            source='ai',
            auto_send=False,
            confidence=0.0
        )
```

### AI适配器服务 (services/ai_adapter.py)

```python
import os
import requests
from typing import Optional

def get_ai_reply(content: str, context: str = None) -> str:
    """获取AI回复"""
    try:
        # 获取AI模型配置
        model = os.environ.get('AI_MODEL', 'stub')
        
        if model == 'openai':
            return get_openai_reply(content, context)
        elif model == 'qwen':
            return get_qwen_reply(content, context)
        elif model == 'ernie':
            return get_ernie_reply(content, context)
        else:
            return get_stub_reply(content, context)
    except Exception as e:
        print(f"AI回复失败: {e}")
        return "抱歉，AI服务暂时不可用。"

def get_openai_reply(content: str, context: str = None) -> str:
    """OpenAI回复"""
    api_key = os.environ.get('OPENAI_API_KEY')
    if not api_key:
        return "OpenAI API密钥未配置"
    
    model = os.environ.get('OPENAI_MODEL', 'gpt-4o-mini')
    
    prompt = f"作为客服助手，请回复以下客户问题：\n{content}"
    if context:
        prompt += f"\n\n参考信息：\n{context}"
    
    response = requests.post(
        'https://api.openai.com/v1/chat/completions',
        headers={
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        },
        json={
            'model': model,
            'messages': [
                {'role': 'system', 'content': '你是一个专业的客服助手，请用友好、专业的语气回复客户问题。'},
                {'role': 'user', 'content': prompt}
            ],
            'max_tokens': 500,
            'temperature': 0.7
        },
        timeout=30
    )
    
    if response.status_code == 200:
        result = response.json()
        return result['choices'][0]['message']['content']
    else:
        return f"OpenAI API错误: {response.status_code}"

def get_stub_reply(content: str, context: str = None) -> str:
    """占位回复"""
    return f"这是对消息'{content[:50]}...'的自动回复。"
```

### 任务调度服务 (services/scheduler.py)

```python
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
from flask import current_app
import logging

scheduler = BackgroundScheduler()

def start_scheduler(app):
    """启动任务调度器"""
    with app.app_context():
        try:
            # 添加未读检测任务
            scheduler.add_job(
                func=check_unread_messages,
                trigger=IntervalTrigger(seconds=10),
                id='unread_check',
                name='未读消息检测',
                replace_existing=True
            )
            
            # 启动调度器
            scheduler.start()
            logging.info("任务调度器启动成功")
        except Exception as e:
            logging.error(f"任务调度器启动失败: {e}")

def check_unread_messages():
    """检查未读消息"""
    try:
        from ..models import Shop, Message
        from .qianniu_monitor import check_unread_in_region
        
        # 获取所有启用的店铺
        shops = Shop.query.filter(
            Shop.config_json.like('%"auto_mode": true%')
        ).all()
        
        for shop in shops:
            try:
                # 解析配置
                import json
                config = json.loads(shop.config_json) if shop.config_json else {}
                ocr_region = config.get('ocr_region', [])
                unread_threshold = config.get('unread_threshold', 0.02)
                
                if not ocr_region:
                    continue
                
                # 检查未读消息
                score = check_unread_in_region(ocr_region)
                if score >= unread_threshold:
                    # 触发OCR采集
                    from .qianniu_monitor import capture_ocr_content
                    content = capture_ocr_content(ocr_region)
                    
                    if content:
                        # 创建消息记录
                        message = Message(
                            shop_id=shop.id,
                            customer_id='auto_detected',
                            content=content,
                            source='qianniu'
                        )
                        db.session.add(message)
                        db.session.commit()
                        
                        # 处理消息
                        from .message_handler import process_message
                        result = process_message(message)
                        
                        # 根据结果决定是否自动发送
                        if result.auto_send:
                            # 自动发送
                            from .qianniu_monitor import send_reply
                            send_reply(result.reply, shop.qianniu_title)
                            message.status = 'answered'
                        else:
                            # 进入审核队列
                            message.status = 'review'
                            audit_item = AuditQueueItem(
                                message_id=message.id,
                                status='pending'
                            )
                            db.session.add(audit_item)
                        
                        db.session.commit()
                        
            except Exception as e:
                logging.error(f"处理店铺 {shop.name} 时出错: {e}")
                continue
                
    except Exception as e:
        logging.error(f"未读消息检测失败: {e}")

def stop_scheduler():
    """停止任务调度器"""
    if scheduler.running:
        scheduler.shutdown()
        logging.info("任务调度器已停止")
```

## 工具函数

### 安全工具 (utils/security.py)

```python
from functools import wraps
from flask import jsonify
from flask_login import current_user

def require_roles(*roles):
    """角色权限装饰器"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                return jsonify({"error": "unauthorized"}), 401
            
            if current_user.role not in roles:
                return jsonify({"error": "forbidden"}), 403
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

def validate_shop_access(shop_id):
    """验证店铺访问权限"""
    if current_user.role == 'superadmin':
        return True
    
    if current_user.role == 'admin' and current_user.shop_id == shop_id:
        return True
    
    return False
```

### 数据库管理 (utils/db_manager.py)

```python
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from flask import current_app

def get_db_connection():
    """获取数据库连接"""
    database_url = current_app.config.get('SQLALCHEMY_DATABASE_URI')
    engine = create_engine(database_url)
    Session = sessionmaker(bind=engine)
    return Session()

def execute_raw_sql(sql: str, params: dict = None):
    """执行原生SQL"""
    session = get_db_connection()
    try:
        result = session.execute(text(sql), params or {})
        session.commit()
        return result
    except Exception as e:
        session.rollback()
        raise e
    finally:
        session.close()

def health_check():
    """数据库健康检查"""
    try:
        session = get_db_connection()
        session.execute(text('SELECT 1'))
        session.close()
        return True
    except Exception as e:
        print(f"数据库健康检查失败: {e}")
        return False
```

## 错误处理

### 全局错误处理

```python
from flask import jsonify
from werkzeug.exceptions import HTTPException

@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "not_found", "message": "资源不存在"}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "internal_error", "message": "服务器内部错误"}), 500

@app.errorhandler(HTTPException)
def handle_http_exception(error):
    return jsonify({
        "error": error.name.lower().replace(' ', '_'),
        "message": error.description
    }), error.code
```

### API错误处理

```python
def handle_api_error(error, operation="操作"):
    """统一API错误处理"""
    if isinstance(error, ValueError):
        return jsonify({"error": "invalid_input", "message": str(error)}), 400
    elif isinstance(error, PermissionError):
        return jsonify({"error": "permission_denied", "message": "权限不足"}), 403
    elif isinstance(error, FileNotFoundError):
        return jsonify({"error": "file_not_found", "message": "文件不存在"}), 404
    else:
        return jsonify({"error": "internal_error", "message": f"{operation}失败"}), 500
```

## 性能优化

### 数据库优化

```python
# 查询优化
def get_shop_with_messages(shop_id):
    """获取店铺及其消息（使用JOIN优化）"""
    return db.session.query(Shop).options(
        db.joinedload(Shop.messages)
    ).filter(Shop.id == shop_id).first()

# 分页查询
def get_messages_paginated(page=1, per_page=20):
    """分页获取消息"""
    return Message.query.order_by(Message.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )

# 批量操作
def batch_update_messages(message_ids, updates):
    """批量更新消息"""
    Message.query.filter(Message.id.in_(message_ids)).update(updates)
    db.session.commit()
```

### 缓存策略

```python
from functools import lru_cache
import redis

# 内存缓存
@lru_cache(maxsize=128)
def get_shop_config(shop_id):
    """获取店铺配置（带缓存）"""
    shop = Shop.query.get(shop_id)
    if shop and shop.config_json:
        import json
        return json.loads(shop.config_json)
    return {}

# Redis缓存
redis_client = redis.Redis(host='localhost', port=6379, db=0)

def cache_ai_reply(content, reply, ttl=3600):
    """缓存AI回复"""
    key = f"ai_reply:{hash(content)}"
    redis_client.setex(key, ttl, reply)

def get_cached_ai_reply(content):
    """获取缓存的AI回复"""
    key = f"ai_reply:{hash(content)}"
    return redis_client.get(key)
```

## 测试

### 单元测试

```python
import pytest
from app import create_app, db
from models import User, Shop

@pytest.fixture
def app():
    """测试应用"""
    app = create_app('testing')
    with app.app_context():
        db.create_all()
        yield app
        db.drop_all()

@pytest.fixture
def client(app):
    """测试客户端"""
    return app.test_client()

def test_create_shop(client):
    """测试创建店铺"""
    response = client.post('/api/shops', json={
        'name': '测试店铺',
        'qianniu_title': '千牛-测试店铺'
    })
    assert response.status_code == 201
    assert response.json['name'] == '测试店铺'

def test_user_authentication(client):
    """测试用户认证"""
    # 创建测试用户
    user = User(username='test', role='admin')
    user.set_password('password')
    db.session.add(user)
    db.session.commit()
    
    # 测试登录
    response = client.post('/api/auth/login', json={
        'username': 'test',
        'password': 'password'
    })
    assert response.status_code == 200
    assert response.json['ok'] is True
```

## 部署配置

### 生产环境配置

```python
# 生产环境启动
if __name__ == '__main__':
    from waitress import serve
    serve(app, host='0.0.0.0', port=5002, threads=4)
```

### Docker配置

```dockerfile
FROM python:3.12-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 5002

CMD ["python", "-m", "houduan.app"]
```

---

**文档版本**: v1.0  
**最后更新**: 2025-01-21  
**维护人员**: 后端团队
